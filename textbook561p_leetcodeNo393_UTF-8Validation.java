/*
UTF-8 바이트 순서의 이진 포맷 표
Number of Bytes    |        UTF-8 Octet Sequence
                   |              (binary)
--------------------+-----------------------------------------
        1          |   0xxxxxxx
        2          |   110xxxxx 10xxxxxx
        3          |   1110xxxx 10xxxxxx 10xxxxxx
        4          |   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
*/


//실행시간은 1밀리초였고, 이는 상위 0% 성능이었습니다.
/*
 * 문제에서 설명하는 규칙을 이해하는 것이 상당히 까다로운 문제였습니다.
 * Input 데이터가 data = [197,130,1] 이렇게 주어졌을 때, 이 데이터 각각을 2진수로 변환하면 다음과 같습니다.
 * 11000101(==197) 10000010(==130) 00000001(==1)
 * 
 * 197의 경우 이진 포맷 표에서 2번 항목에 해당합니다.
 * 그렇다면, 130의 경우도 2번 항목에 따라서 10xxxxxx의 형식을 따라야 합니다.
 * 마지막 1의 경우 1번 항목에 포함되므로 최종적으로 true를 리턴합니다.
 * 
 * 이번엔 입력값이 data = [235,140,4]인 경우를 보겠습니다. 이것을 2진수로 바꾸면,
 * 11101011 10001100 00000100와 같습니다.
 * 첫 번째 숫자가 1110xxxx 꼴이므로 3번 항목을 따라야 합니다.
 * 그런데, 입력값의 마지막 항목인 4가 10xxxxxx꼴이 아니기 때문에 최종적으로 false를 리턴합니다.
 * 
*/
class Solution {
    public boolean validUtf8(int[] data) {
        
        int check = 0;
        
        for (int c : data) {
            
            if (check == 0) {
                //바이트 포맷 표에서 4번 항목에 해당하는 경우입니다.
                //check를 3로 초기화 함으로써, 뒤에 살펴봐야 하는 것들이 3개가 남았음을 나타냅니다.
                if (c >> 3 == 0b11110) check = 3;

                //바이트 포맷 표에서 3번 항목에 해당하는 경우입니다.
                //check를 2로 초기화 함으로써, 뒤에 살펴봐야 하는 것들이 2개가 남았음을 나타냅니다.
                else if (c >> 4 == 0b1110) check = 2;

                //바이트 포맷 포에서 2번 항목에 해당하는 경우입니다.
                //check를 1로 초기화 함으로써, 뒤에 살펴봐야 하는 것들이 1개가 남았음을 나타냅니다.
                else if (c >> 5 == 0b110) check = 1;

                //바이트 포맷 포에서 1번 항목에 해당하는 경우입니다.                
                //그런데 1번 항목에 해당하면서도 가장 왼쪽에 있는 숫자가 0이 아닌 경우 바로 false를 리턴합니다.
                else if (c >> 7 != 0) return false;
            }//if
            
            //check가 0이 아닌 경우를 처리하기 위한 것입니다.
            //바이트 포맷 표의 2,3,4 항목 각각에 대해서 10xxxxxx로 표기돼 있는 부분을 판단하기 위한 것입니다.
            //그래서 >> 6 이라는 unsigned right shift 연산을 실행한 것입니다.
            //언사인드 우측 시프트 연산을 실행한 결과가 10xxxxxx의 포맷에 맞지 않을 경우 바로 false를 리턴하면서 종료합니다.
            else {
                if (c >> 6 != 0b10) return false;

                //check를 --해줍니다. UTF-8 바이트 포맷 표에 적합한 입력배열이 들어왔다면, for루프를 전부 돌고난 다음에는 check가 0이 될 수밖에 없습니다.
                check--;
            }//el
            
        }//for
        
        //check가 0인 경우에 true를 리턴하고, 그렇지 않으면 false를 리턴합니다.
        if(check == 0) return true;
        else return false;
    }
}//main class
