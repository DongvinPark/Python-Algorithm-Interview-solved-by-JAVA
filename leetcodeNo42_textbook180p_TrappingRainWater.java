//첫 번째 풀이는 투 포인터를 활용했습니다. 실행시간은 1밀리초였고, 이는 상위 8%의 성능으로 100명중 8등에 해당하는 실행속도입니다.
//코드의 길이는 짧지만, 재미있는 반복구조를 발견할 수 있습니다.
class Solution {
    public int trap(int[] height) {
        
        int volume = 0;
        int left = 0;//시작할 때는 가장 왼쪽 인덱스의 값으로 레프트(left)를 설정하고,
        int lMax = height[left];//그 인덱스에서의 높이를 왼쪽 최댓값 즉, 엘맥스(lMax)로 설정합니다.
        int right = height.length-1;//마찬가지로 가장 오른쪽 인덱스의 값으로 라이트(right)를 설정하고,
        int rMax = height[right];// 그 인덱스에서의 높이를 오른쪽 최댓값 즉, 라이트맥스(rMax)로 설정합니다.
        
        while(left < right){//루프가 시작되지 전에는 당연히 레프트의 값이 라이트의 값보다 작을 수밖에 없기 때문에 루프에 바로 진입하게 됩니다.
            
            //루프에 진입하자마자 하는 일은 레프트맥스와 라이트맥스를 새로 갱신하는 일입니다.
            lMax = Math.max(height[left] , lMax);//레프트맥스는 현재 인덱스의 높이와 현재 레프트맥스의 값 중 큰 값으로 갱신합니다. 둘이 같을 경우, 그 같은 값으로 갱신됩니다. 이 코드에 의해서, 기존의 레프트 맥스보다 현재의 높이가 더 높을 경우, 그 새로운 값으로 레프트맥스가 갱신될 수 있습니다.
            rMax = Math.max(height[right], rMax);//라이트맥스도 현재 인덱스의 높이와 현재 라이트맥스의 값 중 큰 값으로 갱신합니다. 둘이 같을 경우, 그 같은 값으로 갱신됩니다. 이 코드에 의해서, 기존의 라이트 맥스보다 현재의 높이가 더 높을 경우, 그 새로운 값으로 라이트맥스가 갱신될 수 있습니다.
            
            if(lMax <= rMax){//이 부분이 중요합니다. 빗물이 모이기 위해서는 왼쪽벽과 오른쪽 벽이 모두 존재해야 합니다. if 파트에 진입한 경우는 라이트맥스가 레프트 맥스보다 큰 상황입니다. 이때는 오른쪽벽이 라이트맥스에 의해서 확보된 상황이므로, 레프트 맥스와 현재 높이의 차이만큼의 빗물을 현재의 인덱스에서 확보할 수 있게 됩니다.
                volume+= (lMax - height[left]);
                left ++;//그리고, 레프트에 +1을 해줌으로써, 왼쪽 끝(즉, 입력 배열의 시작점)에서 오른쪽으로 진행하는 방향으로 다음 인덱스의 위치에서 빗물을 모을 수 있는지 판단할 수 있게 해줍니다.
            }
            else{
                volume+= (rMax - height[right]);//else 파트로 진입했다면, 레프트맥스에 의해서 왼쪽 벽이 확보된 상황입니다. if파트와 마찬가지로, 레프트 맥스에 의해서 왼쪽 벽이 확보된 상황이기에 라이트맥스와 현재 높이의 차이만큼의 빗물을 현재의 인덱스에서 확보할 수 있게 됩니다.
                right --;//그리고 라이트에 -1을 해줌으로써, 오른쪽 끝(즉, 입력 배열의 마지막 인덱스)에서 왼쪽으로 진행하는 방향으로 다음 인덱스의 위치에서 빗물을 모을 수 있는지 판단할 수 있게 해줍니다.
            }
            
        }//while >>> 실제 이 루프를 돌려보면, 처음에는 가장 왼쪽 벽의 높이와 가장 오른쪽 벽이 높이 중 더 낮은 쪽에서 먼저 탐색을 시작하게 됩니다. 서로 같을 경우엔 왼쪽에서부터 시작합니다.
        //그렇게 왼쪽 끝과 오른쪽 끝 중 한 쪽에서 먼저 탐색을 시작하다가 탐색을 하던 방향에서 반대쪽의 맥스 값보다 높은 값이 나올 경우, 탐색의 방향이 역전됩니다. 그렇게 역전된 방향으로 탐색을 계속하다가 역시, 반대쪽의 맥스 값보다 더 큰 높이를 만나게 될 경우, 탐색방향은 다시 한 번 역전 됩니다.
        //이렇게 현재 인덱스의 높이 값에 따라서 탐색의 방향을 바꿔나가는 방식으로 탐색을 계속하다보면, 어느 순간에 레프트와 라이트의 값을 서로 같게 되고 그 순간 탐색 루프의 지속 조건을 위배하면서 루프를 탈출합니다.
        
        return volume;//이렇게 최종 계산된 빗물의 양을 반환합니다.
        
    }//main
}//main class
