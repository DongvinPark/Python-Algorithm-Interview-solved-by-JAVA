//실행시긴은 0밀리초였지만, 대부분의 풀이가 0밀리초에 구간에 집중돼 있어서 큰 의미는 없었습니다.
/*
* 이번 풀이는 다이나믹 프로그래밍 중 타뷸레이션이라는 상향식 기법을 이용한 풀이입니다.
*
* 문제에서 제시하는 규칙이 어려워 보이지만, 차분히 분석해보면 결국 또 다른 피보나치 수열 문제임을 알 수 있습니다.
*
* 우선 n = 1,2,3,4,5 ... 인 경우에 대해서 직접 조사를 해 보면서 규칙을 파악해보겠습니다.
* 계단을 오를 때 우리가 선택할 수 있는 경우의 수는 1,2 두 가지입니다.
* 1 또는 2를 몇 개를 선택하든 그 합은 어차피 계단의 숫자인 n과 일치합니다.
* 즉, n=3 일 때, 1+1+1 이든, (1+1)+1, 1+(1+1)이든 어차피 다 3이라는 것입니다.
* 결국 2를 선택한다는 것을 나열돼 있는 1 두개를 서로 묶어주는 것과 마찬가지인 것입니다.
*
* 따라서 인접한 1 두개를 선택하는 경우의 수를 나눠보면, n에 대하여 정답을 추론할 수 있고,
* n 값에 따른 정답의 변화를 추적해보면 결국 피보나치 수열의 규칙을 갖게 됩니다.
*
* + 기호는 생략하고 인접한 1 두 개끼리 묶는 경우의 수를 나열해 보면 이를 명확히 확인할 수 있습니다.
*
*    n=1        n=2           n=3                n=4                n=5       ......
*     1         11            111                (11)(11)          (11)1(11)
*    정답 1     (11)           (11)1              (11)11            (11)(11)1
*             정답 2           1(11)              1(11)1            1(11)(11)
*                             정답 3              11(11)            (11)111
*                                                1111              1(11)11
*                                               정답 5              11(11)1
*                                                                  111(11)
*                                                                  11111
*                                                                   정답 8
*
*
*
* */
class Solution {
    public int climbStairs(int n) {
        //return type is int

        //정답을 빨리 낼 수 있는 경우를 처리해줍니다.
        if(n==1) return 1;
        if(n==2) return 2;

        //피보나치 수열 전개를 위한 초항 설정을 해 줍니다.
        int before = 1;
        int curAnswer = 2;

        //입력값 3부터 시작합니다.
        for(int i=2 ; i < n; i++){

            int temp = curAnswer;

            curAnswer = (curAnswer + before);

            //다음루프 준비용입니다.
            before = temp;

        }//for

        return curAnswer;

    }//main
}//main class









//배열을 만들어둬서 풀이하는 방법도 있습니다. 사용하는 자료구조가 배열이라는 것만 빼면 첫 번째 풀이와
//본질적으로 동일한 로직을 사용하고 있습니다.
//실행시간은 첫 번째 풀이와 똑같은 0밀리초입니다.
class Solution {
    public int climbStairs(int n) {
        //return type is int

        int[]F = new int[46];


        if(n>=0){ F[0] = 0; }

        if(n>=1){ F[1] = 1; }

        if(n>=2){ F[2] = 2; }

        for(int i =3;i<=n;i++){
            F[i] = F[i-1]+F[i-2];
        }
        return F[n];

    }//main
}//main class
