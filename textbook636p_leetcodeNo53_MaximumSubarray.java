//실행시간은 2밀리초였고, 이는 상위 25%에 해당하는 성능이었지만, 대부분의 풀이가 1,2 밀리초 구간에 몰려 있어서
//큰 의미는 없었습니다.
/*
* 이번 풀이는 카데인 알고리즘이라는 다이나믹 프로그래밍 기법을 충실하게 따르고 있습니다.
*
* 카데믹 알고리즘이 다이나믹 프로그래밍인 이유는, 피보나치 수열 문제와 마찬가지로, 직전의 루프의 계산결과를
* 이번 루프에서도 활용하기 때문입니다.
*
* 예를 들어서 input = -2,1,-3,4,-1,2,1,-5,4 이러한 상황이라면, 정답은 6입니다.
*
* 물론 서브 배열의 크기를 1 ~ (input.length-1) 인 경우에 대해 모두 브루트 포스로 조사해서 찾아내는 방법도 있지만,
* 이는 O(N^2)의 시간복잡도를 가지는 비효율적인 풀이입니다.
*
* 서브 배열의 구성 요소들의 합이 최댓값이 되도록 만든다는 것은,
* 현재의 서브배열의 합이 이전 서브배열의 합의 결과에 의하여 영향을 받는다는 것을 의미합니다.
*
* 즉, input = -2,1,-3,4,-1,2,1,-5,4 입력이 이러할 때,
* 배열을 차례대로 순회해 나가면서 이전 서브 배열의 합이 현재의 요소에 의해서 어떠한 영향을 받는지를 판단하여
* 현재 서브배열의 합을 정답인 최댓값의 초기화에 사용할 것인지 말 것인지를 배열을 차례대로 순회하면서 판단하면 됩니다.
*
* 이 때, 직전의 서브 배열의 합이 음수라면, 그것은 최댓값이 될 수 없으므로, 직전 서브 배열의 합은 버려야 합니다.
*
* 반면, 직전 서브배열이 0 이상인 수라면, 이것은 최댓값이 될 수 있는 가능성을 가지고 있으므로 일단 현재 인덱스의 값과
* 합하여 현재 서브 배열의 합을 계산해 줍니다.
*
* 이러한 과정을 거쳐서 구한 서브배열의 합은 다음 for 루프에서 사용됩니다. 이렇게 함으로써 직전 서브배열의 합들을
* 매 for 루프마다 다시 계산하는 비효율성을 제거할 수 있습니다.
*
* 다음 for loop로 넘어가기 전에 이번에 구한 서브 배열의 합이 현재의 최댓값보다 크다면, 현재의 최댓값을
* 이번에 구한 서브루프의 합으로 초기화 해줍니다.
*
*
*  index 값 .    =  0    1     2     3      4     5     6      7     8
* 입력이 input    = -2,   1,   -3,    4,    -1,    2,    1,    -5,    4 이러할 때,
* 각각의 인덱스
* 에서 계산될
* 수 있는 서브
* 배열의 합은
* 이와 같습니다. >>  -2     1    -2     4      3      5     6     1     5
*
* 1 인덱스에서 직전 서브 배열의 합(==beforeSum)은 -2입니다. 따라서 이것은 최댓값이 될 수 없으므로 -2 는 버리고,
* beforeSum을 현재 요소 값인 1로 초기화합니다.
*
* 2 인덱스에서 직전 서브 배열의 합은 1입니다. 이것은 양수이므로 현재 요소 값인 -3과 1을 더한 -2로 초기화합니다.
*
* 3 인덱스에서 직전 서브 배열의 합은 2 인덱스에서 계산한 -2 입니다. 이것은 1인덱스에서와 마찬가지이므로 현재 요소 값인 4로
* beforeSum을 초기화 해줍니다.
*
* 이와 같은 과정을 밟아 나가면, 최종적으로 6인덱스에서 최댓값인 6을 찾을 수 있고, 결국 정답은 6이 되는 것입니다.
* */
class Solution {
    public int maxSubArray(int[] nums) {
        //return type is int

        //요소가 하나뿐일 때는 그냥 그 요소를 정답으로 반환하면 됩니다.
        if(nums.length == 1) return nums[0];


        //정답과 beforeSum을 nums[0]으로 초기화 시키는 것이 중요합니다.
        //이것은 입력 배열이 [-1, -32] 같이 둘 다 음수인 경우를 걸러내기 위해서입니다.
        int answer = nums[0];
        int beforeSum = nums[0];

        //for 루프는 1부터 시작해야 합니다. 그래야 직전 서브 배열의 합(==beforeSum)을 비교해나갈 수 있기 때문입니다.
        for(int i = 1; i<nums.length; i++){

            //beforeSum의 상태에 따라서 이번 루프에서의 서브배열의 합이자 다음 루프에서도 사용될 beforeSum을
            // 어떻게 초기화 시킬지를 결정합니다.
            if(beforeSum >= 0){
                beforeSum = nums[i] + beforeSum;
            }
            else{
                beforeSum = nums[i];
            }

            //새로 초기화한 서브 배열의 합이 기존의 정답 기록보다 크다면 정답을 새로 구한 서브 배열의 합으로 초기화 해줍니다.
            if(beforeSum >= answer){answer = beforeSum;}

        }//for

        return answer;

    }//main
}//main class
